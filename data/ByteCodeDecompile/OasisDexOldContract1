#
#  Panoramix v4 Oct 2019 
#  Decompiled source of 0x14FBCA95be7e99C15Cc2996c6C9d841e54B79425
# 
#  Let's make the world open source 
# 
#
#  I failed with these: 
#  - sellAllAmount(address _pay_gem, uint256 _pay_amt, address _buy_gem, uint256 _min_fill_amount)
#  - offer(uint256 _pay_amt, address _pay_gem, uint256 _buy_amt, address _buy_gem, uint256 _pos)
#  - insert(uint256 _id, uint256 _pos)
#  - cancel(uint256 _imageId)
#  - buyAllAmount(address _buy_gem, uint256 _buy_amt, address _pay_gem, uint256 _max_fill_amount)
#  - kill(bytes32 _id)
#  - offer(uint256 _pay_amt, address _pay_gem, uint256 _buy_amt, address _buy_gem, uint256 _pos, bool _rounding)
#  All the rest is below.
#

const getTime = uint64(block.timestamp)

def storage:
  authorityAddress is addr at storage 0
  owner is addr at storage 1
  last_offer_id is uint256 at storage 2
  offers is mapping of struct at storage 3
  buyEnabled is uint8 at storage 4 offset 80
  stor4 is uint8 at storage 4
  stopped is uint8 at storage 4 offset 72
  stor4 is uint256 at storage 4 offset 80
  stor4 is uint256 at storage 4 offset 88
  matchingEnabled is uint8 at storage 4 offset 88
  close_time is uint64 at storage 4 offset 8
  _rank is mapping of struct at storage 5
  bestOffer is mapping of uint256 at storage 6
  _span is mapping of uint256 at storage 7
  minSell is mapping of uint256 at storage 8
  _near is mapping of uint256 at storage 9
  stor10 is mapping of uint8 at storage 10
  firstUnsortedOffer is uint256 at storage 11

def matchingEnabled(): # not payable
  return bool(matchingEnabled)

def getBestOffer(address _sell_gem, address _buy_gem): # not payable
  return bestOffer[addr(_sell_gem)][addr(_buy_gem)]

def last_offer_id(): # not payable
  return last_offer_id

def getOffer(uint256 _id): # not payable
  return offers[_id].field_0, offers[_id].field_256, offers[_id].field_512, offers[_id].field_768

def getMinSell(address _pay_gem): # not payable
  return minSell[addr(_pay_gem)]

def getNextUnsortedOffer(uint256 _id): # not payable
  return _near[_id]

def close_time(): # not payable
  return close_time

def _span(address _param1, address _param2): # not payable
  return _span[_param1][_param2]

def _best(address _param1, address _param2): # not payable
  return bestOffer[_param1][_param2]

def stopped(): # not payable
  return bool(stopped)

def getOfferCount(address _sell_gem, address _buy_gem): # not payable
  return _span[addr(_sell_gem)][addr(_buy_gem)]

def offers(uint256 _param1): # not payable
  return offers[_param1].field_0, 
         offers[_param1].field_256,
         offers[_param1].field_512,
         offers[_param1].field_768,
         offers[_param1].field_1024,
         offers[_param1].field_1024

def getFirstUnsortedOffer(): # not payable
  return firstUnsortedOffer

def owner(): # not payable
  return owner

def getBetterOffer(uint256 _id): # not payable
  return _rank[_id].field_0

def _dust(address _param1): # not payable
  return minSell[_param1]

def getWorseOffer(uint256 _id): # not payable
  return _rank[_id].field_256

def _menu(bytes32 _param1): # not payable
  return bool(stor10[_param1])

def _near(uint256 _param1): # not payable
  return _near[_param1]

def authority(): # not payable
  return authorityAddress

def _rank(uint256 _param1): # not payable
  return _rank[_param1].field_0, _rank[_param1].field_256, _rank[_param1].field_512

def getOwner(uint256 _ownerIndex): # not payable
  return offers[_ownerIndex].field_1024

def buyEnabled(): # not payable
  return bool(buyEnabled)

#
#  Regular functions
#

def _fallback() payable: # default function
  revert

def isActive(uint256 _id): # not payable
  return (offers[_id].field_1184 > 0)

def isClosed(): # not payable
  if stopped:
      return bool(stopped)
  return (uint64(block.timestamp) > close_time)

def isTokenPairWhitelisted(address _baseToken, address _quoteToken): # not payable
  if stor10[_baseToken][_quoteToken]:
      return bool(stor10[_baseToken][_quoteToken])
  return bool(stor10[_quoteToken][_baseToken])

def stop(): # not payable
  if this.address != caller:
      if owner != caller:
          require authorityAddress
          require ext_code.size(authorityAddress)
          call authorityAddress.canCall(address src, address dst, bytes4 sig) with:
               gas gas_remaining - 710 wei
              args caller, addr(this.address), call.func_hash
          require ext_call.success
          require ext_call.return_data[0]
  stopped = 1

def isOfferSorted(uint256 _id): # not payable
  if _rank[_id].field_0:
      return bool(_rank[_id].field_0)
  if _rank[_id].field_256:
      return bool(_rank[_id].field_256)
  return (bestOffer[stor3[_id].field_256][stor3[_id].field_768] == _id)

def del_rank(uint256 _id): # not payable
  require offers[_id].field_1184 <= 0
  require _rank[_id].field_512
  require _rank[_id].field_512 < block.number - 10
  _rank[_id].field_0 = 0
  _rank[_id].field_256 = 0
  _rank[_id].field_512 = 0
  log LogDelete(
        address keeper=caller,
        uint256 id=_id)
  return 1

def setOwner(address _new): # not payable
  if this.address != caller:
      if owner != caller:
          require authorityAddress
          require ext_code.size(authorityAddress)
          call authorityAddress.canCall(address src, address dst, bytes4 sig) with:
               gas gas_remaining - 710 wei
              args caller, addr(this.address), call.func_hash
          require ext_call.success
          require ext_call.return_data[0]
  owner = _new
  log LogSetOwner(address owner=_new)

def setAuthority(address _authority): # not payable
  if this.address != caller:
      if owner != caller:
          require authorityAddress
          require ext_code.size(authorityAddress)
          call authorityAddress.canCall(address src, address dst, bytes4 sig) with:
               gas gas_remaining - 710 wei
              args caller, addr(this.address), call.func_hash
          require ext_call.success
          require ext_call.return_data[0]
  authorityAddress = _authority_
  log LogSetAuthority(address authority=_authority_)

def setBuyEnabled(bool _buyEnabled): # not payable
  if this.address != caller:
      if owner != caller:
          require authorityAddress
          require ext_code.size(authorityAddress)
          call authorityAddress.canCall(address src, address dst, bytes4 sig) with:
               gas gas_remaining - 710 wei
              args caller, addr(this.address), call.func_hash
          require ext_call.success
          require ext_call.return_data[0]
  Mask(176, 0, stor4.field_80) = Mask(176, 0, _buyEnabled_)
  log LogBuyEnabled(bool isEnabled=bool(uint8(_buyEnabled_)))
  return 1

def setMatchingEnabled(bool _matchingEnabled): # not payable
  if this.address != caller:
      if owner != caller:
          require authorityAddress
          require ext_code.size(authorityAddress)
          call authorityAddress.canCall(address src, address dst, bytes4 sig) with:
               gas gas_remaining - 710 wei
              args caller, addr(this.address), call.func_hash
          require ext_call.success
          require ext_call.return_data[0]
  Mask(168, 0, stor4.field_88) = Mask(168, 0, _matchingEnabled_)
  log LogMatchingEnabled(bool isEnabled=bool(uint8(_matchingEnabled_)))
  return 1

def bump(bytes32 _id): # not payable
  require offers[_id_].field_1184 > 0
  require not stopped
  require uint64(block.timestamp) <= close_time
  log LogBump(
        bytes32 id=offers[_id_].field_256,
        bytes32 pair=offers[_id_].field_768,
        address maker=offers[_id_].field_0,
        address haveToken=offers[_id_].field_512,
        address wantToken=offers[_id_].field_1184,
        uint128 haveAmount=_id_,
        uint128 wantAmount=sha3(offers[_id_].field_256, offers[_id_].field_768),
        uint64 timestamp=offers[_id_].field_1024)

def setMinSell(address _pay_gem, uint256 _dust): # not payable
  if this.address != caller:
      if owner != caller:
          require authorityAddress
          require ext_code.size(authorityAddress)
          call authorityAddress.canCall(address src, address dst, bytes4 sig) with:
               gas gas_remaining - 710 wei
              args caller, addr(this.address), call.func_hash
          require ext_call.success
          require ext_call.return_data[0]
  log call.func_hash: call.value, Array(len=calldata.size, data=call.data, _dust
  minSell[addr(_pay_gem)] = _dust
  log LogMinSell(
        address pay_gem=addr(_pay_gem),
        uint256 min_amount=_dust)
  return 1

def addTokenPairWhitelist(address _baseToken, address _quoteToken): # not payable
  if this.address != caller:
      if owner != caller:
          require authorityAddress
          require ext_code.size(authorityAddress)
          call authorityAddress.canCall(address src, address dst, bytes4 sig) with:
               gas gas_remaining - 710 wei
              args caller, addr(this.address), call.func_hash
          require ext_call.success
          require ext_call.return_data[0]
  log call.func_hash: call.value, Array(len=calldata.size, data=call.data
  require not stor10[_baseToken][_quoteToken]
  require not stor10[_quoteToken][_baseToken]
  require _baseToken
  require _quoteToken
  stor10[_baseToken][_quoteToken] = 1
  log LogAddTokenPairWhitelist(
        address baseToken=addr(_baseToken),
        address quoteToken=_quoteToken)
  return 1

def remTokenPairWhitelist(address _baseToken, address _quoteToken): # not payable
  if this.address != caller:
      if owner != caller:
          require authorityAddress
          require ext_code.size(authorityAddress)
          call authorityAddress.canCall(address src, address dst, bytes4 sig) with:
               gas gas_remaining - 710 wei
              args caller, addr(this.address), call.func_hash
          require ext_call.success
          require ext_call.return_data[0]
  log call.func_hash: call.value, Array(len=calldata.size, data=call.data
  if not stor10[_baseToken][_quoteToken]:
      require stor10[_quoteToken][_baseToken]
  stor10[_baseToken][_quoteToken] = 0
  stor10[_quoteToken][_baseToken] = 0
  log LogRemTokenPairWhitelist(
        address baseToken=addr(_baseToken),
        address quoteToken=_quoteToken)
  return 1

def getPayAmount(address _pay_gem, address _buy_gem, uint256 _buy_amt): # not payable
  s = bestOffer[addr(_buy_gem)][addr(_pay_gem)]
  t = 0
  idx = _buy_amt
  while idx > offers[stor6[addr(_buy_gem)][addr(_pay_gem)]].field_0:
      require t + offers[s].field_512 >= t
      require idx - offers[s].field_0 <= idx
      if idx - offers[s].field_0 <= 0:
          mem[0] = s
          mem[32] = 3
          s = s
          t = t + offers[s].field_512
          idx = idx - offers[s].field_0
          continue 
      require _rank[s].field_256
      mem[0] = _rank[s].field_256
      mem[32] = 3
      s = _rank[s].field_256
      t = t + offers[s].field_512
      idx = idx - offers[s].field_0
      continue 
  require 1000000000 * 10^18 * offers[s].field_512 / 1000000000 * 10^18 == offers[s].field_512
  require (1000000000 * 10^18 * offers[s].field_512) + offers[s].field_1 >= 1000000000 * 10^18 * offers[s].field_512
  require offers[s].field_0
  if not (1000000000 * 10^18 * offers[s].field_512) + offers[s].field_1 / offers[s].field_0:
      require t >= t
      return t
  require (1000000000 * 10^18 * offers[s].field_512) + offers[s].field_1 / offers[s].field_0
  require 10^9 * idx * (1000000000 * 10^18 * offers[s].field_512) + offers[s].field_1 / offers[s].field_0 / (1000000000 * 10^18 * offers[s].field_512) + offers[s].field_1 / offers[s].field_0 == 10^9 * idx
  require (10^9 * idx * (1000000000 * 10^18 * offers[s].field_512) + offers[s].field_1 / offers[s].field_0) + 500000000 * 10^18 >= 10^9 * idx * (1000000000 * 10^18 * offers[s].field_512) + offers[s].field_1 / offers[s].field_0
  require t + ((10^9 * idx * (1000000000 * 10^18 * offers[s].field_512) + offers[s].field_1 / offers[s].field_0) + 500000000 * 10^18 / 1000000000 * 10^18 / 10^9) >= t
  return (t + ((10^9 * idx * (1000000000 * 10^18 * offers[s].field_512) + offers[s].field_1 / offers[s].field_0) + 500000000 * 10^18 / 1000000000 * 10^18 / 10^9))

def getBuyAmount(address _buy_gem, address _pay_gem, uint256 _pay_amt): # not payable
  s = bestOffer[addr(_buy_gem)][addr(_pay_gem)]
  t = 0
  idx = _pay_amt
  while idx > offers[stor6[addr(_buy_gem)][addr(_pay_gem)]].field_512:
      require t + offers[s].field_0 >= t
      require idx - offers[s].field_512 <= idx
      if idx - offers[s].field_512 <= 0:
          mem[0] = s
          mem[32] = 3
          s = s
          t = t + offers[s].field_0
          idx = idx - offers[s].field_512
          continue 
      require _rank[s].field_256
      mem[0] = _rank[s].field_256
      mem[32] = 3
      s = _rank[s].field_256
      t = t + offers[s].field_0
      idx = idx - offers[s].field_512
      continue 
  require 1000000000 * 10^18 * offers[s].field_0 / 1000000000 * 10^18 == offers[s].field_0
  require (1000000000 * 10^18 * offers[s].field_0) + offers[s].field_513 >= 1000000000 * 10^18 * offers[s].field_0
  require offers[s].field_512
  if not (1000000000 * 10^18 * offers[s].field_0) + offers[s].field_513 / offers[s].field_512:
      require t >= t
      return t
  require (1000000000 * 10^18 * offers[s].field_0) + offers[s].field_513 / offers[s].field_512
  require 10^9 * idx * (1000000000 * 10^18 * offers[s].field_0) + offers[s].field_513 / offers[s].field_512 / (1000000000 * 10^18 * offers[s].field_0) + offers[s].field_513 / offers[s].field_512 == 10^9 * idx
  require (10^9 * idx * (1000000000 * 10^18 * offers[s].field_0) + offers[s].field_513 / offers[s].field_512) + 500000000 * 10^18 >= 10^9 * idx * (1000000000 * 10^18 * offers[s].field_0) + offers[s].field_513 / offers[s].field_512
  require t + ((10^9 * idx * (1000000000 * 10^18 * offers[s].field_0) + offers[s].field_513 / offers[s].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / 10^9) >= t
  return (t + ((10^9 * idx * (1000000000 * 10^18 * offers[s].field_0) + offers[s].field_513 / offers[s].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / 10^9))

def make(address _haveToken, address _wantToken, uint128 _haveAmount, uint128 _wantAmount): # not payable
  if not stor10[_haveToken][_wantToken]:
      require stor10[_wantToken][_haveToken]
  if not matchingEnabled:
      require not stopped
      require uint64(block.timestamp) <= close_time
      require not uint8(stor4.field_0)
      uint8(stor4.field_0) = 1
      require _haveAmount == _haveAmount
      require _wantAmount == _wantAmount
      require _haveAmount > 0
      require _haveToken
      require _wantAmount > 0
      require _wantToken
      require _wantToken != _haveToken
      last_offer_id++
      offers[stor2 + 1].field_0 = _haveAmount
      offers[stor2 + 1].field_128 = 0
      offers[stor2 + 1].field_256 = _haveToken
      offers[stor2 + 1].field_512 = _wantAmount
      offers[stor2 + 1].field_640 = 0
      offers[stor2 + 1].field_768 = _wantToken
      offers[stor2 + 1].field_1024 = caller
      offers[stor2 + 1].field_1184 = uint64(block.timestamp)
      require ext_code.size(_haveToken)
      call _haveToken.transferFrom(address from, address to, uint256 value) with:
           gas gas_remaining - 710 wei
          args caller, addr(this.address), _haveAmount
      require ext_call.success
      require ext_call.return_data[0]
      log LogItemUpdate(uint256 id=(last_offer_id + 1))
      log LogMake(
            bytes32 id=addr(_haveToken),
            bytes32 pair=addr(_wantToken),
            address maker=_haveAmount << 128,
            address haveToken=_wantAmount << 128,
            address wantToken=uint64(block.timestamp),
            uint128 haveAmount=last_offer_id + 1,
            uint128 wantAmount=sha3(_haveToken, _wantToken),
            uint64 timestamp=caller)
      uint8(stor4.field_0) = 0
  else:
      require minSell[addr(_haveToken)] <= _haveAmount
      require not stopped
      require uint64(block.timestamp) <= close_time
      require not uint8(stor4.field_0)
      uint8(stor4.field_0) = 1
      require _haveAmount == _haveAmount
      require _wantAmount == _wantAmount
      require _haveAmount > 0
      require _haveToken
      require _wantAmount > 0
      require _wantToken
      require _wantToken != _haveToken
      last_offer_id++
      offers[stor2 + 1].field_0 = _haveAmount
      offers[stor2 + 1].field_128 = 0
      offers[stor2 + 1].field_256 = _haveToken
      offers[stor2 + 1].field_512 = _wantAmount
      offers[stor2 + 1].field_640 = 0
      offers[stor2 + 1].field_768 = _wantToken
      offers[stor2 + 1].field_1024 = caller
      offers[stor2 + 1].field_1184 = uint64(block.timestamp)
      require ext_code.size(_haveToken)
      call _haveToken.transferFrom(address from, address to, uint256 value) with:
           gas gas_remaining - 710 wei
          args caller, addr(this.address), _haveAmount
      require ext_call.success
      require ext_call.return_data[0]
      log LogItemUpdate(uint256 id=(last_offer_id + 1))
      log LogMake(
            bytes32 id=addr(_haveToken),
            bytes32 pair=addr(_wantToken),
            address maker=_haveAmount << 128,
            address haveToken=_wantAmount << 128,
            address wantToken=uint64(block.timestamp),
            uint128 haveAmount=last_offer_id + 1,
            uint128 wantAmount=sha3(_haveToken, _wantToken),
            uint64 timestamp=caller)
      uint8(stor4.field_0) = 0
      _near[stor2 + 1] = firstUnsortedOffer
      firstUnsortedOffer = last_offer_id + 1
      log LogUnsortedOffer(uint256 id=(last_offer_id + 1))
  return (last_offer_id + 1)

def offer(uint256 _sell_how_much, address _sell_which_token, uint256 _buy_how_much, address _buy_which_token): # not payable
  if not stor10[_sell_which_token][_buy_which_token]:
      require stor10[_buy_which_token][_sell_which_token]
  if not matchingEnabled:
      require not stopped
      require uint64(block.timestamp) <= close_time
      require not uint8(stor4.field_0)
      uint8(stor4.field_0) = 1
      require _sell_how_much == uint128(_sell_how_much)
      require _buy_how_much == uint128(_buy_how_much)
      require _sell_how_much > 0
      require _sell_which_token
      require _buy_how_much > 0
      require _buy_which_token
      require _buy_which_token != _sell_which_token
      last_offer_id++
      offers[stor2 + 1].field_0 = _sell_how_much
      offers[stor2 + 1].field_256 = _sell_which_token
      offers[stor2 + 1].field_512 = _buy_how_much
      offers[stor2 + 1].field_768 = _buy_which_token
      offers[stor2 + 1].field_1024 = caller
      offers[stor2 + 1].field_1184 = uint64(block.timestamp)
      require ext_code.size(_sell_which_token)
      call _sell_which_token.transferFrom(address from, address to, uint256 value) with:
           gas gas_remaining - 710 wei
          args caller, addr(this.address), _sell_how_much
      require ext_call.success
      require ext_call.return_data[0]
      log LogItemUpdate(uint256 id=(last_offer_id + 1))
      log LogMake(
            bytes32 id=addr(_sell_which_token),
            bytes32 pair=addr(_buy_which_token),
            address maker=_sell_how_much << 128,
            address haveToken=_buy_how_much << 128,
            address wantToken=uint64(block.timestamp),
            uint128 haveAmount=last_offer_id + 1,
            uint128 wantAmount=sha3(_sell_which_token, _buy_which_token),
            uint64 timestamp=caller)
      uint8(stor4.field_0) = 0
  else:
      require minSell[addr(_sell_which_token)] <= _sell_how_much
      require not stopped
      require uint64(block.timestamp) <= close_time
      require not uint8(stor4.field_0)
      uint8(stor4.field_0) = 1
      require _sell_how_much == uint128(_sell_how_much)
      require _buy_how_much == uint128(_buy_how_much)
      require _sell_how_much > 0
      require _sell_which_token
      require _buy_how_much > 0
      require _buy_which_token
      require _buy_which_token != _sell_which_token
      last_offer_id++
      offers[stor2 + 1].field_0 = _sell_how_much
      offers[stor2 + 1].field_256 = _sell_which_token
      offers[stor2 + 1].field_512 = _buy_how_much
      offers[stor2 + 1].field_768 = _buy_which_token
      offers[stor2 + 1].field_1024 = caller
      offers[stor2 + 1].field_1184 = uint64(block.timestamp)
      require ext_code.size(_sell_which_token)
      call _sell_which_token.transferFrom(address from, address to, uint256 value) with:
           gas gas_remaining - 710 wei
          args caller, addr(this.address), _sell_how_much
      require ext_call.success
      require ext_call.return_data[0]
      log LogItemUpdate(uint256 id=(last_offer_id + 1))
      log LogMake(
            bytes32 id=addr(_sell_which_token),
            bytes32 pair=addr(_buy_which_token),
            address maker=_sell_how_much << 128,
            address haveToken=_buy_how_much << 128,
            address wantToken=uint64(block.timestamp),
            uint128 haveAmount=last_offer_id + 1,
            uint128 wantAmount=sha3(_sell_which_token, _buy_which_token),
            uint64 timestamp=caller)
      uint8(stor4.field_0) = 0
      _near[stor2 + 1] = firstUnsortedOffer
      firstUnsortedOffer = last_offer_id + 1
      log LogUnsortedOffer(uint256 id=(last_offer_id + 1))
  return (last_offer_id + 1)

def take(bytes32 _id, uint128 _maxTakeAmount): # not payable
  require offers[_id].field_1184 > 0
  require not stopped
  require uint64(block.timestamp) <= close_time
  if matchingEnabled:
      require buyEnabled
      if _maxTakeAmount == offers[_id].field_0:
          if _rank[_id].field_0:
              require _span[stor3[_id].field_256][stor3[_id].field_768] > 0
              require not _rank[_id].field_512
              if not _rank[_id].field_0:
                  if not _rank[_id].field_256:
                      require bestOffer[stor3[_id].field_256][stor3[_id].field_768] == _id
              if _id == bestOffer[stor3[_id].field_256][stor3[_id].field_768]:
                  bestOffer[stor3[_id].field_256][stor3[_id].field_768] = _rank[_id].field_256
              else:
                  require _id == _rank[_rank[_id].field_0].field_256
                  _rank[_rank[_id].field_0].field_256 = _rank[_id].field_256
              if _rank[_id].field_256:
                  require _id == _rank[_rank[_id].field_256].field_0
                  _rank[_rank[_id].field_256].field_0 = _rank[_id].field_0
              _span[stor3[_id].field_256][stor3[_id].field_768]--
              _rank[_id].field_512 = block.number
          else:
              if _rank[_id].field_256:
                  require _span[stor3[_id].field_256][stor3[_id].field_768] > 0
                  require not _rank[_id].field_512
                  if not _rank[_id].field_0:
                      if not _rank[_id].field_256:
                          require bestOffer[stor3[_id].field_256][stor3[_id].field_768] == _id
                  if _id == bestOffer[stor3[_id].field_256][stor3[_id].field_768]:
                      bestOffer[stor3[_id].field_256][stor3[_id].field_768] = _rank[_id].field_256
                  else:
                      require _id == _rank[_rank[_id].field_0].field_256
                      _rank[_rank[_id].field_0].field_256 = _rank[_id].field_256
                  if _rank[_id].field_256:
                      require _id == _rank[_rank[_id].field_256].field_0
                      _rank[_rank[_id].field_256].field_0 = _rank[_id].field_0
                  _span[stor3[_id].field_256][stor3[_id].field_768]--
                  _rank[_id].field_512 = block.number
              else:
                  if bestOffer[stor3[_id].field_256][stor3[_id].field_768] == _id:
                      require _span[stor3[_id].field_256][stor3[_id].field_768] > 0
                      require not _rank[_id].field_512
                      if not _rank[_id].field_0:
                          if not _rank[_id].field_256:
                              require bestOffer[stor3[_id].field_256][stor3[_id].field_768] == _id
                      if _id == bestOffer[stor3[_id].field_256][stor3[_id].field_768]:
                          bestOffer[stor3[_id].field_256][stor3[_id].field_768] = _rank[_id].field_256
                      else:
                          require _id == _rank[_rank[_id].field_0].field_256
                          _rank[_rank[_id].field_0].field_256 = _rank[_id].field_256
                      if _rank[_id].field_256:
                          require _id == _rank[_rank[_id].field_256].field_0
                          _rank[_rank[_id].field_256].field_0 = _rank[_id].field_0
                      _span[stor3[_id].field_256][stor3[_id].field_768]--
                      _rank[_id].field_512 = block.number
  require offers[_id].field_1184 > 0
  require not stopped
  require uint64(block.timestamp) <= close_time
  require not uint8(stor4.field_0)
  uint8(stor4.field_0) = 1
  if not offers[_id].field_512:
      require offers[_id].field_0
      require 0 / offers[_id].field_0 == uint128(0 / offers[_id].field_0)
      require _maxTakeAmount == _maxTakeAmount
      if not _maxTakeAmount:
          uint8(stor4.field_0) = 0
          revert
      if not 0 / offers[_id].field_0:
          uint8(stor4.field_0) = 0
          revert
      if _maxTakeAmount > offers[_id].field_0:
          uint8(stor4.field_0) = 0
          revert
      if 0 / offers[_id].field_0 > offers[_id].field_512:
          uint8(stor4.field_0) = 0
          revert
      require offers[_id].field_0 - _maxTakeAmount <= offers[_id].field_0
      offers[_id].field_0 -= _maxTakeAmount
      require offers[_id].field_512 - (0 / offers[_id].field_0) <= offers[_id].field_512
      offers[_id].field_512 -= 0 / offers[_id].field_0
      require ext_code.size(offers[_id].field_768)
      call offers[_id].field_768.transferFrom(address from, address to, uint256 value) with:
           gas gas_remaining - 710 wei
          args caller, offers[_id].field_1024, 0 / offers[_id].field_0
      require ext_call.success
      require ext_call.return_data[0]
      require ext_code.size(offers[_id].field_256)
      call offers[_id].field_256.transfer(address to, uint256 value) with:
           gas gas_remaining - 710 wei
          args caller, _maxTakeAmount
      require ext_call.success
      require ext_call.return_data[0]
      log LogItemUpdate(uint256 id=_id)
      log LogTake(
            bytes32 id=_id,
            bytes32 pair=offers[_id].field_256,
            address maker=offers[_id].field_768,
            address haveToken=_maxTakeAmount << 128,
            address wantToken=0 / offers[_id].field_0 << 128,
            address taker=uint64(block.timestamp),
            uint128 takeAmount=sha3(offers[_id].field_256, offers[_id].field_768),
            uint128 giveAmount=offers[_id].field_1024,
            uint64 timestamp=caller)
      log LogTrade(
            uint256 pay_amt=_maxTakeAmount << 128,
            address pay_gem=0 / offers[_id].field_0,
            uint256 buy_amt=offers[_id].field_256,
            address buy_gem=offers[_id].field_768)
  else:
      require offers[_id].field_512
      require _maxTakeAmount * offers[_id].field_512 / offers[_id].field_512 == _maxTakeAmount
      require offers[_id].field_0
      require _maxTakeAmount * offers[_id].field_512 / offers[_id].field_0 == uint128(_maxTakeAmount * offers[_id].field_512 / offers[_id].field_0)
      require _maxTakeAmount == _maxTakeAmount
      if not _maxTakeAmount:
          uint8(stor4.field_0) = 0
          revert
      if not _maxTakeAmount * offers[_id].field_512 / offers[_id].field_0:
          uint8(stor4.field_0) = 0
          revert
      if _maxTakeAmount > offers[_id].field_0:
          uint8(stor4.field_0) = 0
          revert
      if _maxTakeAmount * offers[_id].field_512 / offers[_id].field_0 > offers[_id].field_512:
          uint8(stor4.field_0) = 0
          revert
      require offers[_id].field_0 - _maxTakeAmount <= offers[_id].field_0
      offers[_id].field_0 -= _maxTakeAmount
      require offers[_id].field_512 - (_maxTakeAmount * offers[_id].field_512 / offers[_id].field_0) <= offers[_id].field_512
      offers[_id].field_512 -= _maxTakeAmount * offers[_id].field_512 / offers[_id].field_0
      require ext_code.size(offers[_id].field_768)
      call offers[_id].field_768.transferFrom(address from, address to, uint256 value) with:
           gas gas_remaining - 710 wei
          args caller, offers[_id].field_1024, _maxTakeAmount * offers[_id].field_512 / offers[_id].field_0
      require ext_call.success
      require ext_call.return_data[0]
      require ext_code.size(offers[_id].field_256)
      call offers[_id].field_256.transfer(address to, uint256 value) with:
           gas gas_remaining - 710 wei
          args caller, _maxTakeAmount
      require ext_call.success
      require ext_call.return_data[0]
      log LogItemUpdate(uint256 id=_id)
      log LogTake(
            bytes32 id=_id,
            bytes32 pair=offers[_id].field_256,
            address maker=offers[_id].field_768,
            address haveToken=_maxTakeAmount << 128,
            address wantToken=_maxTakeAmount * offers[_id].field_512 / offers[_id].field_0 << 128,
            address taker=uint64(block.timestamp),
            uint128 takeAmount=sha3(offers[_id].field_256, offers[_id].field_768),
            uint128 giveAmount=offers[_id].field_1024,
            uint64 timestamp=caller)
      log LogTrade(
            uint256 pay_amt=_maxTakeAmount << 128,
            address pay_gem=_maxTakeAmount * offers[_id].field_512 / offers[_id].field_0,
            uint256 buy_amt=offers[_id].field_256,
            address buy_gem=offers[_id].field_768)
  if not offers[_id].field_0:
      offers[_id].field_0 = 0
      offers[_id].field_256 = 0
      offers[_id].field_512 = 0
      offers[_id].field_768 = 0
      offers[_id].field_1024 = 0
  uint8(stor4.field_0) = 0

def buy(uint256 _x, uint256 _y): # not payable
  require offers[_x].field_1184 > 0
  require not stopped
  require uint64(block.timestamp) <= close_time
  if not matchingEnabled:
      require offers[_x].field_1184 > 0
      require not stopped
      require uint64(block.timestamp) <= close_time
      require not uint8(stor4.field_0)
      uint8(stor4.field_0) = 1
      if not offers[_x].field_512:
          require offers[_x].field_0
          require 0 / offers[_x].field_0 == uint128(0 / offers[_x].field_0)
          require _y == uint128(_y)
          if not _y:
              uint8(stor4.field_0) = 0
              return 0
          if not 0 / offers[_x].field_0:
              uint8(stor4.field_0) = 0
              return 0
          if _y > offers[_x].field_0:
              uint8(stor4.field_0) = 0
              return 0
          if 0 / offers[_x].field_0 > offers[_x].field_512:
              uint8(stor4.field_0) = 0
              return 0
          require offers[_x].field_0 - _y <= offers[_x].field_0
          offers[_x].field_0 -= _y
          require offers[_x].field_512 - (0 / offers[_x].field_0) <= offers[_x].field_512
          offers[_x].field_512 -= 0 / offers[_x].field_0
          require ext_code.size(offers[_x].field_768)
          call offers[_x].field_768.transferFrom(address from, address to, uint256 value) with:
               gas gas_remaining - 710 wei
              args caller, offers[_x].field_1024, 0 / offers[_x].field_0
          require ext_call.success
          require ext_call.return_data[0]
          require ext_code.size(offers[_x].field_256)
          call offers[_x].field_256.transfer(address to, uint256 value) with:
               gas gas_remaining - 710 wei
              args caller, _y
          require ext_call.success
          require ext_call.return_data[0]
          log LogItemUpdate(uint256 id=_x)
          log LogTake(
                bytes32 id=_x,
                bytes32 pair=offers[_x].field_256,
                address maker=offers[_x].field_768,
                address haveToken=_y << 128,
                address wantToken=0 / offers[_x].field_0 << 128,
                address taker=uint64(block.timestamp),
                uint128 takeAmount=sha3(offers[_x].field_256, offers[_x].field_768),
                uint128 giveAmount=offers[_x].field_1024,
                uint64 timestamp=caller)
          log LogTrade(
                uint256 pay_amt=_y,
                address pay_gem=0 / offers[_x].field_0,
                uint256 buy_amt=offers[_x].field_256,
                address buy_gem=offers[_x].field_768)
      else:
          require offers[_x].field_512
          require _y * offers[_x].field_512 / offers[_x].field_512 == _y
          require offers[_x].field_0
          require _y * offers[_x].field_512 / offers[_x].field_0 == uint128(_y * offers[_x].field_512 / offers[_x].field_0)
          require _y == uint128(_y)
          if not _y:
              uint8(stor4.field_0) = 0
              return 0
          if not _y * offers[_x].field_512 / offers[_x].field_0:
              uint8(stor4.field_0) = 0
              return 0
          if _y > offers[_x].field_0:
              uint8(stor4.field_0) = 0
              return 0
          if _y * offers[_x].field_512 / offers[_x].field_0 > offers[_x].field_512:
              uint8(stor4.field_0) = 0
              return 0
          require offers[_x].field_0 - _y <= offers[_x].field_0
          offers[_x].field_0 -= _y
          require offers[_x].field_512 - (_y * offers[_x].field_512 / offers[_x].field_0) <= offers[_x].field_512
          offers[_x].field_512 -= _y * offers[_x].field_512 / offers[_x].field_0
          require ext_code.size(offers[_x].field_768)
          call offers[_x].field_768.transferFrom(address from, address to, uint256 value) with:
               gas gas_remaining - 710 wei
              args caller, offers[_x].field_1024, _y * offers[_x].field_512 / offers[_x].field_0
          require ext_call.success
          require ext_call.return_data[0]
          require ext_code.size(offers[_x].field_256)
          call offers[_x].field_256.transfer(address to, uint256 value) with:
               gas gas_remaining - 710 wei
              args caller, _y
          require ext_call.success
          require ext_call.return_data[0]
          log LogItemUpdate(uint256 id=_x)
          log LogTake(
                bytes32 id=_x,
                bytes32 pair=offers[_x].field_256,
                address maker=offers[_x].field_768,
                address haveToken=_y << 128,
                address wantToken=_y * offers[_x].field_512 / offers[_x].field_0 << 128,
                address taker=uint64(block.timestamp),
                uint128 takeAmount=sha3(offers[_x].field_256, offers[_x].field_768),
                uint128 giveAmount=offers[_x].field_1024,
                uint64 timestamp=caller)
          log LogTrade(
                uint256 pay_amt=_y,
                address pay_gem=_y * offers[_x].field_512 / offers[_x].field_0,
                uint256 buy_amt=offers[_x].field_256,
                address buy_gem=offers[_x].field_768)
  else:
      require buyEnabled
      if _y == offers[_x].field_0:
          if _rank[_x].field_0:
              require _span[stor3[_x].field_256][stor3[_x].field_768] > 0
              require not _rank[_x].field_512
              if not _rank[_x].field_0:
                  if not _rank[_x].field_256:
                      require bestOffer[stor3[_x].field_256][stor3[_x].field_768] == _x
              if _x == bestOffer[stor3[_x].field_256][stor3[_x].field_768]:
                  bestOffer[stor3[_x].field_256][stor3[_x].field_768] = _rank[_x].field_256
              else:
                  require _x == _rank[_rank[_x].field_0].field_256
                  _rank[_rank[_x].field_0].field_256 = _rank[_x].field_256
              if _rank[_x].field_256:
                  require _x == _rank[_rank[_x].field_256].field_0
                  _rank[_rank[_x].field_256].field_0 = _rank[_x].field_0
              _span[stor3[_x].field_256][stor3[_x].field_768]--
              _rank[_x].field_512 = block.number
          else:
              if _rank[_x].field_256:
                  require _span[stor3[_x].field_256][stor3[_x].field_768] > 0
                  require not _rank[_x].field_512
                  if not _rank[_x].field_0:
                      if not _rank[_x].field_256:
                          require bestOffer[stor3[_x].field_256][stor3[_x].field_768] == _x
                  if _x == bestOffer[stor3[_x].field_256][stor3[_x].field_768]:
                      bestOffer[stor3[_x].field_256][stor3[_x].field_768] = _rank[_x].field_256
                  else:
                      require _x == _rank[_rank[_x].field_0].field_256
                      _rank[_rank[_x].field_0].field_256 = _rank[_x].field_256
                  if _rank[_x].field_256:
                      require _x == _rank[_rank[_x].field_256].field_0
                      _rank[_rank[_x].field_256].field_0 = _rank[_x].field_0
                  _span[stor3[_x].field_256][stor3[_x].field_768]--
                  _rank[_x].field_512 = block.number
              else:
                  if bestOffer[stor3[_x].field_256][stor3[_x].field_768] == _x:
                      require _span[stor3[_x].field_256][stor3[_x].field_768] > 0
                      require not _rank[_x].field_512
                      if not _rank[_x].field_0:
                          if not _rank[_x].field_256:
                              require bestOffer[stor3[_x].field_256][stor3[_x].field_768] == _x
                      if _x == bestOffer[stor3[_x].field_256][stor3[_x].field_768]:
                          bestOffer[stor3[_x].field_256][stor3[_x].field_768] = _rank[_x].field_256
                      else:
                          require _x == _rank[_rank[_x].field_0].field_256
                          _rank[_rank[_x].field_0].field_256 = _rank[_x].field_256
                      if _rank[_x].field_256:
                          require _x == _rank[_rank[_x].field_256].field_0
                          _rank[_rank[_x].field_256].field_0 = _rank[_x].field_0
                      _span[stor3[_x].field_256][stor3[_x].field_768]--
                      _rank[_x].field_512 = block.number
      require offers[_x].field_1184 > 0
      require not stopped
      require uint64(block.timestamp) <= close_time
      require not uint8(stor4.field_0)
      uint8(stor4.field_0) = 1
      if not offers[_x].field_512:
          require offers[_x].field_0
          require 0 / offers[_x].field_0 == uint128(0 / offers[_x].field_0)
          require _y == uint128(_y)
          if not _y:
              uint8(stor4.field_0) = 0
              revert
          if not 0 / offers[_x].field_0:
              uint8(stor4.field_0) = 0
              revert
          if _y > offers[_x].field_0:
              uint8(stor4.field_0) = 0
              revert
          if 0 / offers[_x].field_0 > offers[_x].field_512:
              uint8(stor4.field_0) = 0
              revert
          require offers[_x].field_0 - _y <= offers[_x].field_0
          offers[_x].field_0 -= _y
          require offers[_x].field_512 - (0 / offers[_x].field_0) <= offers[_x].field_512
          offers[_x].field_512 -= 0 / offers[_x].field_0
          require ext_code.size(offers[_x].field_768)
          call offers[_x].field_768.transferFrom(address from, address to, uint256 value) with:
               gas gas_remaining - 710 wei
              args caller, offers[_x].field_1024, 0 / offers[_x].field_0
          require ext_call.success
          require ext_call.return_data[0]
          require ext_code.size(offers[_x].field_256)
          call offers[_x].field_256.transfer(address to, uint256 value) with:
               gas gas_remaining - 710 wei
              args caller, _y
          require ext_call.success
          require ext_call.return_data[0]
          log LogItemUpdate(uint256 id=_x)
          log LogTake(
                bytes32 id=_x,
                bytes32 pair=offers[_x].field_256,
                address maker=offers[_x].field_768,
                address haveToken=_y << 128,
                address wantToken=0 / offers[_x].field_0 << 128,
                address taker=uint64(block.timestamp),
                uint128 takeAmount=sha3(offers[_x].field_256, offers[_x].field_768),
                uint128 giveAmount=offers[_x].field_1024,
                uint64 timestamp=caller)
          log LogTrade(
                uint256 pay_amt=_y,
                address pay_gem=0 / offers[_x].field_0,
                uint256 buy_amt=offers[_x].field_256,
                address buy_gem=offers[_x].field_768)
      else:
          require offers[_x].field_512
          require _y * offers[_x].field_512 / offers[_x].field_512 == _y
          require offers[_x].field_0
          require _y * offers[_x].field_512 / offers[_x].field_0 == uint128(_y * offers[_x].field_512 / offers[_x].field_0)
          require _y == uint128(_y)
          if not _y:
              uint8(stor4.field_0) = 0
              revert
          if not _y * offers[_x].field_512 / offers[_x].field_0:
              uint8(stor4.field_0) = 0
              revert
          if _y > offers[_x].field_0:
              uint8(stor4.field_0) = 0
              revert
          if _y * offers[_x].field_512 / offers[_x].field_0 > offers[_x].field_512:
              uint8(stor4.field_0) = 0
              revert
          require offers[_x].field_0 - _y <= offers[_x].field_0
          offers[_x].field_0 -= _y
          require offers[_x].field_512 - (_y * offers[_x].field_512 / offers[_x].field_0) <= offers[_x].field_512
          offers[_x].field_512 -= _y * offers[_x].field_512 / offers[_x].field_0
          require ext_code.size(offers[_x].field_768)
          call offers[_x].field_768.transferFrom(address from, address to, uint256 value) with:
               gas gas_remaining - 710 wei
              args caller, offers[_x].field_1024, _y * offers[_x].field_512 / offers[_x].field_0
          require ext_call.success
          require ext_call.return_data[0]
          require ext_code.size(offers[_x].field_256)
          call offers[_x].field_256.transfer(address to, uint256 value) with:
               gas gas_remaining - 710 wei
              args caller, _y
          require ext_call.success
          require ext_call.return_data[0]
          log LogItemUpdate(uint256 id=_x)
          log LogTake(
                bytes32 id=_x,
                bytes32 pair=offers[_x].field_256,
                address maker=offers[_x].field_768,
                address haveToken=_y << 128,
                address wantToken=_y * offers[_x].field_512 / offers[_x].field_0 << 128,
                address taker=uint64(block.timestamp),
                uint128 takeAmount=sha3(offers[_x].field_256, offers[_x].field_768),
                uint128 giveAmount=offers[_x].field_1024,
                uint64 timestamp=caller)
          log LogTrade(
                uint256 pay_amt=_y,
                address pay_gem=_y * offers[_x].field_512 / offers[_x].field_0,
                uint256 buy_amt=offers[_x].field_256,
                address buy_gem=offers[_x].field_768)
  if not offers[_x].field_0:
      offers[_x].field_0 = 0
      offers[_x].field_256 = 0
      offers[_x].field_512 = 0
      offers[_x].field_768 = 0
      offers[_x].field_1024 = 0
  uint8(stor4.field_0) = 0
  return 1

